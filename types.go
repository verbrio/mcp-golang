// Code generated by schema-generate. DO NOT EDIT.

package mcp

import (
    "encoding/json"
    "errors"
    "fmt"
    "bytes"
)

// Root
type Root interface{}

// Annotated Base for objects that include optional annotations for the client. The client can use annotations to inform how objects are used or displayed
type Annotated struct {
  Annotations *Annotations `json:"annotations,omitempty"`
}

// Annotations 
type Annotations struct {

  // Describes who the intended customer of this object or data is.
  // 
  // It can include multiple entries to indicate content useful for multiple audiences (e.g., `["user", "assistant"]`).
  Audience []string `json:"audience,omitempty"`

  // Describes how important this data is for operating the server.
  // 
  // A value of 1 means "most important," and indicates that the data is
  // effectively required, while 0 means "least important," and indicates that
  // the data is entirely optional.
  Priority float64 `json:"priority,omitempty"`
}

// Argument The argument's information
type Argument struct {

  // The name of the argument
  Name string `json:"name"`

  // The value of the argument to use for completion matching.
  Value string `json:"value"`
}

// BlobResourceContents 
type BlobResourceContents struct {

  // A base64-encoded string representing the binary data of the item.
  Blob string `json:"blob"`

  // The MIME type of this resource, if known.
  MimeType string `json:"mimeType,omitempty"`

  // The URI of this resource.
  Uri string `json:"uri"`
}

// CallToolRequest Used by the client to invoke a tool provided by the server.
type CallToolRequest struct {
  Method string `json:"method"`
  Params *Params `json:"params"`
}

// CallToolResult The server's response to a tool call.
// 
// Any errors that originate from the tool SHOULD be reported inside the result
// object, with `isError` set to true, _not_ as an MCP protocol-level error
// response. Otherwise, the LLM would not be able to see that an error occurred
// and self-correct.
// 
// However, any errors in _finding_ the tool, an error indicating that the
// server does not support tool calls, or any other exceptional conditions,
// should be reported as an MCP error response.
type CallToolResult struct {
  Content []interface{} `json:"content"`

  // Whether the tool call ended in an error.
  // 
  // If not set, this is assumed to be false (the call was successful).
  IsError bool `json:"isError,omitempty"`

  // This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
  Meta map[string]interface{} `json:"_meta,omitempty"`
}

// CancelledNotification This notification can be sent by either side to indicate that it is cancelling a previously-issued request.
// 
// The request SHOULD still be in-flight, but due to communication latency, it is always possible that this notification MAY arrive after the request has already finished.
// 
// This notification indicates that the result will be unused, so any associated processing SHOULD cease.
// 
// A client MUST NOT attempt to cancel its `initialize` request.
type CancelledNotification struct {
  Method string `json:"method"`
  Params *Params `json:"params"`
}

// ClientCapabilities Capabilities a client may support. Known capabilities are defined here, in this schema, but this is not a closed set: any client can define its own, additional capabilities.
type ClientCapabilities struct {

  // Experimental, non-standard capabilities that the client supports.
  Experimental map[string]*ExperimentalItem `json:"experimental,omitempty"`

  // Present if the client supports listing roots.
  Roots *Roots `json:"roots,omitempty"`

  // Present if the client supports sampling from an LLM.
  Sampling *Sampling `json:"sampling,omitempty"`
}

// CompleteRequest A request from the client to the server, to ask for completion options.
type CompleteRequest struct {
  Method string `json:"method"`
  Params *Params `json:"params"`
}

// CompleteResult The server's response to a completion/complete request
type CompleteResult struct {
  Completion *Completion `json:"completion"`

  // This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
  Meta map[string]interface{} `json:"_meta,omitempty"`
}

// Completion 
type Completion struct {

  // Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.
  HasMore bool `json:"hasMore,omitempty"`

  // The total number of completion options available. This can exceed the number of values actually sent in the response.
  Total int `json:"total,omitempty"`

  // An array of completion values. Must not exceed 100 items.
  Values []string `json:"values"`
}

// CreateMessageRequest A request from the server to sample an LLM via the client. The client has full discretion over which model to select. The client should also inform the user before beginning sampling, to allow them to inspect the request (human in the loop) and decide whether to approve it.
type CreateMessageRequest struct {
  Method string `json:"method"`
  Params *Params `json:"params"`
}

// CreateMessageResult The client's response to a sampling/create_message request from the server. The client should inform the user before returning the sampled message, to allow them to inspect the response (human in the loop) and decide whether to allow the server to see it.
type CreateMessageResult struct {
  Content interface{} `json:"content"`

  // This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
  Meta map[string]interface{} `json:"_meta,omitempty"`

  // The name of the model that generated the message.
  Model string `json:"model"`
  Role string `json:"role"`

  // The reason why sampling stopped, if known.
  StopReason string `json:"stopReason,omitempty"`
}

// EmbeddedResource The contents of a resource, embedded into a prompt or tool call result.
// 
// It is up to the client how best to render embedded resources for the benefit
// of the LLM and/or the user.
type EmbeddedResource struct {
  Annotations *Annotations `json:"annotations,omitempty"`
  Resource interface{} `json:"resource"`
  Type string `json:"type"`
}

// Error 
type Error struct {

  // The error type that occurred.
  Code int `json:"code"`

  // Additional information about the error. The value of this member is defined by the sender (e.g. detailed error information, nested errors etc.).
  Data interface{} `json:"data,omitempty"`

  // A short description of the error. The message SHOULD be limited to a concise single sentence.
  Message string `json:"message"`
}

// ExperimentalItem 
type ExperimentalItem struct {
  AdditionalProperties map[string]interface{} `json:"-,omitempty"`
}

// GetPromptRequest Used by the client to get a prompt provided by the server.
type GetPromptRequest struct {
  Method string `json:"method"`
  Params *Params `json:"params"`
}

// GetPromptResult The server's response to a prompts/get request from the client.
type GetPromptResult struct {

  // An optional description for the prompt.
  Description string `json:"description,omitempty"`
  Messages []*PromptMessage `json:"messages"`

  // This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
  Meta map[string]interface{} `json:"_meta,omitempty"`
}

// ImageContent An image provided to or from an LLM.
type ImageContent struct {
  Annotations *Annotations `json:"annotations,omitempty"`

  // The base64-encoded image data.
  Data string `json:"data"`

  // The MIME type of the image. Different providers may support different image types.
  MimeType string `json:"mimeType"`
  Type string `json:"type"`
}

// Implementation Describes the name and version of an MCP implementation.
type Implementation struct {
  Name string `json:"name"`
  Version string `json:"version"`
}

// InitializeRequest This request is sent from the client to the server when it first connects, asking it to begin initialization.
type InitializeRequest struct {
  Method string `json:"method"`
  Params *Params `json:"params"`
}

// InitializeResult After receiving an initialize request from the client, the server sends this response.
type InitializeResult struct {
  Capabilities *ServerCapabilities `json:"capabilities"`

  // Instructions describing how to use the server and its features.
  // 
  // This can be used by clients to improve the LLM's understanding of available tools, resources, etc. It can be thought of like a "hint" to the model. For example, this information MAY be added to the system prompt.
  Instructions string `json:"instructions,omitempty"`

  // This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
  Meta map[string]interface{} `json:"_meta,omitempty"`

  // The version of the Model Context Protocol that the server wants to use. This may not match the version that the client requested. If the client cannot support this version, it MUST disconnect.
  ProtocolVersion string `json:"protocolVersion"`
  ServerInfo *Implementation `json:"serverInfo"`
}

// InitializedNotification This notification is sent from the client to the server after initialization has finished.
type InitializedNotification struct {
  Method string `json:"method"`
  Params *Params `json:"params,omitempty"`
}

// InputSchema A JSON Schema object defining the expected parameters for the tool.
type InputSchema struct {
  Properties map[string]*PropertiesItem `json:"properties,omitempty"`
  Required []string `json:"required,omitempty"`
  Type string `json:"type"`
}

// JSONRPCError A response to a request that indicates an error occurred.
type JSONRPCError struct {
  Error *Error `json:"error"`
  Id interface{} `json:"id"`
  Jsonrpc string `json:"jsonrpc"`
}

// JSONRPCNotification A notification which does not expect a response.
type JSONRPCNotification struct {
  Jsonrpc string `json:"jsonrpc"`
  Method string `json:"method"`
  Params *Params `json:"params,omitempty"`
}

// JSONRPCRequest A request that expects a response.
type JSONRPCRequest struct {
  Id interface{} `json:"id"`
  Jsonrpc string `json:"jsonrpc"`
  Method string `json:"method"`
  Params *Params `json:"params,omitempty"`
}

// JSONRPCResponse A successful (non-error) response to a request.
type JSONRPCResponse struct {
  Id interface{} `json:"id"`
  Jsonrpc string `json:"jsonrpc"`
  Result *Result `json:"result"`
}

// ListPromptsRequest Sent from the client to request a list of prompts and prompt templates the server has.
type ListPromptsRequest struct {
  Method string `json:"method"`
  Params *Params `json:"params,omitempty"`
}

// ListPromptsResult The server's response to a prompts/list request from the client.
type ListPromptsResult struct {

  // This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
  Meta map[string]interface{} `json:"_meta,omitempty"`

  // An opaque token representing the pagination position after the last returned result.
  // If present, there may be more results available.
  NextCursor string `json:"nextCursor,omitempty"`
  Prompts []*Prompt `json:"prompts"`
}

// ListResourceTemplatesRequest Sent from the client to request a list of resource templates the server has.
type ListResourceTemplatesRequest struct {
  Method string `json:"method"`
  Params *Params `json:"params,omitempty"`
}

// ListResourceTemplatesResult The server's response to a resources/templates/list request from the client.
type ListResourceTemplatesResult struct {

  // This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
  Meta map[string]interface{} `json:"_meta,omitempty"`

  // An opaque token representing the pagination position after the last returned result.
  // If present, there may be more results available.
  NextCursor string `json:"nextCursor,omitempty"`
  ResourceTemplates []*ResourceTemplate `json:"resourceTemplates"`
}

// ListResourcesRequest Sent from the client to request a list of resources the server has.
type ListResourcesRequest struct {
  Method string `json:"method"`
  Params *Params `json:"params,omitempty"`
}

// ListResourcesResult The server's response to a resources/list request from the client.
type ListResourcesResult struct {

  // This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
  Meta map[string]interface{} `json:"_meta,omitempty"`

  // An opaque token representing the pagination position after the last returned result.
  // If present, there may be more results available.
  NextCursor string `json:"nextCursor,omitempty"`
  Resources []*Resource `json:"resources"`
}

// ListRootsRequest Sent from the server to request a list of root URIs from the client. Roots allow
// servers to ask for specific directories or files to operate on. A common example
// for roots is providing a set of repositories or directories a server should operate
// on.
// 
// This request is typically used when the server needs to understand the file system
// structure or access specific locations that the client has permission to read from.
type ListRootsRequest struct {
  Method string `json:"method"`
  Params *Params `json:"params,omitempty"`
}

// ListRootsResult The client's response to a roots/list request from the server.
// This result contains an array of Root objects, each representing a root directory
// or file that the server can operate on.
type ListRootsResult struct {

  // This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
  Meta map[string]interface{} `json:"_meta,omitempty"`
  Roots []*Root `json:"roots"`
}

// ListToolsRequest Sent from the client to request a list of tools the server has.
type ListToolsRequest struct {
  Method string `json:"method"`
  Params *Params `json:"params,omitempty"`
}

// ListToolsResult The server's response to a tools/list request from the client.
type ListToolsResult struct {

  // This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
  Meta map[string]interface{} `json:"_meta,omitempty"`

  // An opaque token representing the pagination position after the last returned result.
  // If present, there may be more results available.
  NextCursor string `json:"nextCursor,omitempty"`
  Tools []*Tool `json:"tools"`
}

// Logging Present if the server supports sending log messages to the client.
type Logging struct {
  AdditionalProperties map[string]interface{} `json:"-,omitempty"`
}

// LoggingMessageNotification Notification of a log message passed from server to client. If no logging/setLevel request has been sent from the client, the server MAY decide which messages to send automatically.
type LoggingMessageNotification struct {
  Method string `json:"method"`
  Params *Params `json:"params"`
}

// Meta 
type Meta struct {

  // If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
  ProgressToken interface{} `json:"progressToken,omitempty"`
}

// Metadata Optional metadata to pass through to the LLM provider. The format of this metadata is provider-specific.
type Metadata struct {
  AdditionalProperties map[string]interface{} `json:"-,omitempty"`
}

// ModelHint Hints to use for model selection.
// 
// Keys not declared here are currently left unspecified by the spec and are up
// to the client to interpret.
type ModelHint struct {

  // A hint for a model name.
  // 
  // The client SHOULD treat this as a substring of a model name; for example:
  //  - `claude-3-5-sonnet` should match `claude-3-5-sonnet-20241022`
  //  - `sonnet` should match `claude-3-5-sonnet-20241022`, `claude-3-sonnet-20240229`, etc.
  //  - `claude` should match any Claude model
  // 
  // The client MAY also map the string to a different provider's model name or a different model family, as long as it fills a similar niche; for example:
  //  - `gemini-1.5-flash` could match `claude-3-haiku-20240307`
  Name string `json:"name,omitempty"`
}

// ModelPreferences The server's preferences for model selection, requested of the client during sampling.
// 
// Because LLMs can vary along multiple dimensions, choosing the "best" model is
// rarely straightforward.  Different models excel in different areasâ€”some are
// faster but less capable, others are more capable but more expensive, and so
// on. This interface allows servers to express their priorities across multiple
// dimensions to help clients make an appropriate selection for their use case.
// 
// These preferences are always advisory. The client MAY ignore them. It is also
// up to the client to decide how to interpret these preferences and how to
// balance them against other considerations.
type ModelPreferences struct {

  // How much to prioritize cost when selecting a model. A value of 0 means cost
  // is not important, while a value of 1 means cost is the most important
  // factor.
  CostPriority float64 `json:"costPriority,omitempty"`

  // Optional hints to use for model selection.
  // 
  // If multiple hints are specified, the client MUST evaluate them in order
  // (such that the first match is taken).
  // 
  // The client SHOULD prioritize these hints over the numeric priorities, but
  // MAY still use the priorities to select from ambiguous matches.
  Hints []*ModelHint `json:"hints,omitempty"`

  // How much to prioritize intelligence and capabilities when selecting a
  // model. A value of 0 means intelligence is not important, while a value of 1
  // means intelligence is the most important factor.
  IntelligencePriority float64 `json:"intelligencePriority,omitempty"`

  // How much to prioritize sampling speed (latency) when selecting a model. A
  // value of 0 means speed is not important, while a value of 1 means speed is
  // the most important factor.
  SpeedPriority float64 `json:"speedPriority,omitempty"`
}

// Notification 
type Notification struct {
  Method string `json:"method"`
  Params *Params `json:"params,omitempty"`
}

// PaginatedRequest 
type PaginatedRequest struct {
  Method string `json:"method"`
  Params *Params `json:"params,omitempty"`
}

// PaginatedResult 
type PaginatedResult struct {

  // This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
  Meta map[string]interface{} `json:"_meta,omitempty"`

  // An opaque token representing the pagination position after the last returned result.
  // If present, there may be more results available.
  NextCursor string `json:"nextCursor,omitempty"`
}

// Params 
type Params struct {
  AdditionalProperties map[string]interface{} `json:"-,omitempty"`

  // This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
  Meta map[string]interface{} `json:"_meta,omitempty"`
}

// PingRequest A ping, issued by either the server or the client, to check that the other party is still alive. The receiver must promptly respond, or else may be disconnected.
type PingRequest struct {
  Method string `json:"method"`
  Params *Params `json:"params,omitempty"`
}

// ProgressNotification An out-of-band notification used to inform the receiver of a progress update for a long-running request.
type ProgressNotification struct {
  Method string `json:"method"`
  Params *Params `json:"params"`
}

// Prompt A prompt or prompt template that the server offers.
type Prompt struct {

  // A list of arguments to use for templating the prompt.
  Arguments []*PromptArgument `json:"arguments,omitempty"`

  // An optional description of what this prompt provides
  Description string `json:"description,omitempty"`

  // The name of the prompt or prompt template.
  Name string `json:"name"`
}

// PromptArgument Describes an argument that a prompt can accept.
type PromptArgument struct {

  // A human-readable description of the argument.
  Description string `json:"description,omitempty"`

  // The name of the argument.
  Name string `json:"name"`

  // Whether this argument must be provided.
  Required bool `json:"required,omitempty"`
}

// PromptListChangedNotification An optional notification from the server to the client, informing it that the list of prompts it offers has changed. This may be issued by servers without any previous subscription from the client.
type PromptListChangedNotification struct {
  Method string `json:"method"`
  Params *Params `json:"params,omitempty"`
}

// PromptMessage Describes a message returned as part of a prompt.
// 
// This is similar to `SamplingMessage`, but also supports the embedding of
// resources from the MCP server.
type PromptMessage struct {
  Content interface{} `json:"content"`
  Role string `json:"role"`
}

// PromptReference Identifies a prompt.
type PromptReference struct {

  // The name of the prompt or prompt template
  Name string `json:"name"`
  Type string `json:"type"`
}

// Prompts Present if the server offers any prompt templates.
type Prompts struct {

  // Whether this server supports notifications for changes to the prompt list.
  ListChanged bool `json:"listChanged,omitempty"`
}

// PropertiesItem 
type PropertiesItem struct {
  AdditionalProperties map[string]interface{} `json:"-,omitempty"`
}

// ReadResourceRequest Sent from the client to the server, to read a specific resource URI.
type ReadResourceRequest struct {
  Method string `json:"method"`
  Params *Params `json:"params"`
}

// ReadResourceResult The server's response to a resources/read request from the client.
type ReadResourceResult struct {
  Contents []interface{} `json:"contents"`

  // This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
  Meta map[string]interface{} `json:"_meta,omitempty"`
}

// Request 
type Request struct {
  Method string `json:"method"`
  Params *Params `json:"params,omitempty"`
}

// Resource A known resource that the server is capable of reading.
type Resource struct {
  Annotations *Annotations `json:"annotations,omitempty"`

  // A description of what this resource represents.
  // 
  // This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
  Description string `json:"description,omitempty"`

  // The MIME type of this resource, if known.
  MimeType string `json:"mimeType,omitempty"`

  // A human-readable name for this resource.
  // 
  // This can be used by clients to populate UI elements.
  Name string `json:"name"`

  // The URI of this resource.
  Uri string `json:"uri"`
}

// ResourceContents The contents of a specific resource or sub-resource.
type ResourceContents struct {

  // The MIME type of this resource, if known.
  MimeType string `json:"mimeType,omitempty"`

  // The URI of this resource.
  Uri string `json:"uri"`
}

// ResourceListChangedNotification An optional notification from the server to the client, informing it that the list of resources it can read from has changed. This may be issued by servers without any previous subscription from the client.
type ResourceListChangedNotification struct {
  Method string `json:"method"`
  Params *Params `json:"params,omitempty"`
}

// ResourceReference A reference to a resource or resource template definition.
type ResourceReference struct {
  Type string `json:"type"`

  // The URI or URI template of the resource.
  Uri string `json:"uri"`
}

// ResourceTemplate A template description for resources available on the server.
type ResourceTemplate struct {
  Annotations *Annotations `json:"annotations,omitempty"`

  // A description of what this template is for.
  // 
  // This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
  Description string `json:"description,omitempty"`

  // The MIME type for all resources that match this template. This should only be included if all resources matching this template have the same type.
  MimeType string `json:"mimeType,omitempty"`

  // A human-readable name for the type of resource this template refers to.
  // 
  // This can be used by clients to populate UI elements.
  Name string `json:"name"`

  // A URI template (according to RFC 6570) that can be used to construct resource URIs.
  UriTemplate string `json:"uriTemplate"`
}

// ResourceUpdatedNotification A notification from the server to the client, informing it that a resource has changed and may need to be read again. This should only be sent if the client previously sent a resources/subscribe request.
type ResourceUpdatedNotification struct {
  Method string `json:"method"`
  Params *Params `json:"params"`
}

// Resources Present if the server offers any resources to read.
type Resources struct {

  // Whether this server supports notifications for changes to the resource list.
  ListChanged bool `json:"listChanged,omitempty"`

  // Whether this server supports subscribing to resource updates.
  Subscribe bool `json:"subscribe,omitempty"`
}

// Result 
type Result struct {
  AdditionalProperties map[string]interface{} `json:"-,omitempty"`

  // This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
  Meta map[string]interface{} `json:"_meta,omitempty"`
}

// Root Represents a root directory or file that the server can operate on.
type Root struct {

  // An optional name for the root. This can be used to provide a human-readable
  // identifier for the root, which may be useful for display purposes or for
  // referencing the root in other parts of the application.
  Name string `json:"name,omitempty"`

  // The URI identifying the root. This *must* start with file:// for now.
  // This restriction may be relaxed in future versions of the protocol to allow
  // other URI schemes.
  Uri string `json:"uri"`
}

// Roots Present if the client supports listing roots.
type Roots struct {

  // Whether the client supports notifications for changes to the roots list.
  ListChanged bool `json:"listChanged,omitempty"`
}

// RootsListChangedNotification A notification from the client to the server, informing it that the list of roots has changed.
// This notification should be sent whenever the client adds, removes, or modifies any root.
// The server should then request an updated list of roots using the ListRootsRequest.
type RootsListChangedNotification struct {
  Method string `json:"method"`
  Params *Params `json:"params,omitempty"`
}

// Sampling Present if the client supports sampling from an LLM.
type Sampling struct {
  AdditionalProperties map[string]interface{} `json:"-,omitempty"`
}

// SamplingMessage Describes a message issued to or received from an LLM API.
type SamplingMessage struct {
  Content interface{} `json:"content"`
  Role string `json:"role"`
}

// ServerCapabilities Capabilities that a server may support. Known capabilities are defined here, in this schema, but this is not a closed set: any server can define its own, additional capabilities.
type ServerCapabilities struct {

  // Experimental, non-standard capabilities that the server supports.
  Experimental map[string]*ExperimentalItem `json:"experimental,omitempty"`

  // Present if the server supports sending log messages to the client.
  Logging *Logging `json:"logging,omitempty"`

  // Present if the server offers any prompt templates.
  Prompts *Prompts `json:"prompts,omitempty"`

  // Present if the server offers any resources to read.
  Resources *Resources `json:"resources,omitempty"`

  // Present if the server offers any tools to call.
  Tools *Tools `json:"tools,omitempty"`
}

// SetLevelRequest A request from the client to the server, to enable or adjust logging.
type SetLevelRequest struct {
  Method string `json:"method"`
  Params *Params `json:"params"`
}

// SubscribeRequest Sent from the client to request resources/updated notifications from the server whenever a particular resource changes.
type SubscribeRequest struct {
  Method string `json:"method"`
  Params *Params `json:"params"`
}

// TextContent Text provided to or from an LLM.
type TextContent struct {
  Annotations *Annotations `json:"annotations,omitempty"`

  // The text content of the message.
  Text string `json:"text"`
  Type string `json:"type"`
}

// TextResourceContents 
type TextResourceContents struct {

  // The MIME type of this resource, if known.
  MimeType string `json:"mimeType,omitempty"`

  // The text of the item. This must only be set if the item can actually be represented as text (not binary data).
  Text string `json:"text"`

  // The URI of this resource.
  Uri string `json:"uri"`
}

// Tool Definition for a tool the client can call.
type Tool struct {

  // A human-readable description of the tool.
  Description string `json:"description,omitempty"`

  // A JSON Schema object defining the expected parameters for the tool.
  InputSchema *InputSchema `json:"inputSchema"`

  // The name of the tool.
  Name string `json:"name"`
}

// ToolListChangedNotification An optional notification from the server to the client, informing it that the list of tools it offers has changed. This may be issued by servers without any previous subscription from the client.
type ToolListChangedNotification struct {
  Method string `json:"method"`
  Params *Params `json:"params,omitempty"`
}

// Tools Present if the server offers any tools to call.
type Tools struct {

  // Whether this server supports notifications for changes to the tool list.
  ListChanged bool `json:"listChanged,omitempty"`
}

// UnsubscribeRequest Sent from the client to request cancellation of resources/updated notifications from the server. This should follow a previous resources/subscribe request.
type UnsubscribeRequest struct {
  Method string `json:"method"`
  Params *Params `json:"params"`
}

func (strct *Argument) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Argument) UnmarshalJSON(b []byte) error {
    nameReceived := false
    valueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            nameReceived = true
        case "value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
            valueReceived = true
        }
    }
    // check if name (a required property) was received
    if !nameReceived {
        return errors.New("\"name\" is required but was not present")
    }
    // check if value (a required property) was received
    if !valueReceived {
        return errors.New("\"value\" is required but was not present")
    }
    return nil
}

func (strct *BlobResourceContents) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Blob" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "blob" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"blob\": ")
	if tmp, err := json.Marshal(strct.Blob); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "mimeType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"mimeType\": ")
	if tmp, err := json.Marshal(strct.MimeType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Uri" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "uri" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"uri\": ")
	if tmp, err := json.Marshal(strct.Uri); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BlobResourceContents) UnmarshalJSON(b []byte) error {
    blobReceived := false
    uriReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "blob":
            if err := json.Unmarshal([]byte(v), &strct.Blob); err != nil {
                return err
             }
            blobReceived = true
        case "mimeType":
            if err := json.Unmarshal([]byte(v), &strct.MimeType); err != nil {
                return err
             }
        case "uri":
            if err := json.Unmarshal([]byte(v), &strct.Uri); err != nil {
                return err
             }
            uriReceived = true
        }
    }
    // check if blob (a required property) was received
    if !blobReceived {
        return errors.New("\"blob\" is required but was not present")
    }
    // check if uri (a required property) was received
    if !uriReceived {
        return errors.New("\"uri\" is required but was not present")
    }
    return nil
}

func (strct *CallToolRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Params" field is required
    if strct.Params == nil {
        return nil, errors.New("params is a required field")
    }
    // Marshal the "params" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CallToolRequest) UnmarshalJSON(b []byte) error {
    methodReceived := false
    paramsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
                return err
             }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
                return err
             }
            paramsReceived = true
        }
    }
    // check if method (a required property) was received
    if !methodReceived {
        return errors.New("\"method\" is required but was not present")
    }
    // check if params (a required property) was received
    if !paramsReceived {
        return errors.New("\"params\" is required but was not present")
    }
    return nil
}

func (strct *CallToolResult) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Content" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "content" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"content\": ")
	if tmp, err := json.Marshal(strct.Content); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "isError" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"isError\": ")
	if tmp, err := json.Marshal(strct.IsError); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "_meta" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"_meta\": ")
	if tmp, err := json.Marshal(strct.Meta); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CallToolResult) UnmarshalJSON(b []byte) error {
    contentReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "content":
            if err := json.Unmarshal([]byte(v), &strct.Content); err != nil {
                return err
             }
            contentReceived = true
        case "isError":
            if err := json.Unmarshal([]byte(v), &strct.IsError); err != nil {
                return err
             }
        case "_meta":
            if err := json.Unmarshal([]byte(v), &strct.Meta); err != nil {
                return err
             }
        }
    }
    // check if content (a required property) was received
    if !contentReceived {
        return errors.New("\"content\" is required but was not present")
    }
    return nil
}

func (strct *CancelledNotification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Params" field is required
    if strct.Params == nil {
        return nil, errors.New("params is a required field")
    }
    // Marshal the "params" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CancelledNotification) UnmarshalJSON(b []byte) error {
    methodReceived := false
    paramsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
                return err
             }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
                return err
             }
            paramsReceived = true
        }
    }
    // check if method (a required property) was received
    if !methodReceived {
        return errors.New("\"method\" is required but was not present")
    }
    // check if params (a required property) was received
    if !paramsReceived {
        return errors.New("\"params\" is required but was not present")
    }
    return nil
}

func (strct *CompleteRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Params" field is required
    if strct.Params == nil {
        return nil, errors.New("params is a required field")
    }
    // Marshal the "params" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CompleteRequest) UnmarshalJSON(b []byte) error {
    methodReceived := false
    paramsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
                return err
             }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
                return err
             }
            paramsReceived = true
        }
    }
    // check if method (a required property) was received
    if !methodReceived {
        return errors.New("\"method\" is required but was not present")
    }
    // check if params (a required property) was received
    if !paramsReceived {
        return errors.New("\"params\" is required but was not present")
    }
    return nil
}

func (strct *CompleteResult) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Completion" field is required
    if strct.Completion == nil {
        return nil, errors.New("completion is a required field")
    }
    // Marshal the "completion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"completion\": ")
	if tmp, err := json.Marshal(strct.Completion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "_meta" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"_meta\": ")
	if tmp, err := json.Marshal(strct.Meta); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CompleteResult) UnmarshalJSON(b []byte) error {
    completionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "completion":
            if err := json.Unmarshal([]byte(v), &strct.Completion); err != nil {
                return err
             }
            completionReceived = true
        case "_meta":
            if err := json.Unmarshal([]byte(v), &strct.Meta); err != nil {
                return err
             }
        }
    }
    // check if completion (a required property) was received
    if !completionReceived {
        return errors.New("\"completion\" is required but was not present")
    }
    return nil
}

func (strct *Completion) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "hasMore" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"hasMore\": ")
	if tmp, err := json.Marshal(strct.HasMore); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "total" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"total\": ")
	if tmp, err := json.Marshal(strct.Total); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Values" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "values" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"values\": ")
	if tmp, err := json.Marshal(strct.Values); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Completion) UnmarshalJSON(b []byte) error {
    valuesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "hasMore":
            if err := json.Unmarshal([]byte(v), &strct.HasMore); err != nil {
                return err
             }
        case "total":
            if err := json.Unmarshal([]byte(v), &strct.Total); err != nil {
                return err
             }
        case "values":
            if err := json.Unmarshal([]byte(v), &strct.Values); err != nil {
                return err
             }
            valuesReceived = true
        }
    }
    // check if values (a required property) was received
    if !valuesReceived {
        return errors.New("\"values\" is required but was not present")
    }
    return nil
}

func (strct *CreateMessageRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Params" field is required
    if strct.Params == nil {
        return nil, errors.New("params is a required field")
    }
    // Marshal the "params" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CreateMessageRequest) UnmarshalJSON(b []byte) error {
    methodReceived := false
    paramsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
                return err
             }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
                return err
             }
            paramsReceived = true
        }
    }
    // check if method (a required property) was received
    if !methodReceived {
        return errors.New("\"method\" is required but was not present")
    }
    // check if params (a required property) was received
    if !paramsReceived {
        return errors.New("\"params\" is required but was not present")
    }
    return nil
}

func (strct *CreateMessageResult) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Content" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "content" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"content\": ")
	if tmp, err := json.Marshal(strct.Content); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "_meta" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"_meta\": ")
	if tmp, err := json.Marshal(strct.Meta); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Model" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "model" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"model\": ")
	if tmp, err := json.Marshal(strct.Model); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Role" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "role" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"role\": ")
	if tmp, err := json.Marshal(strct.Role); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "stopReason" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"stopReason\": ")
	if tmp, err := json.Marshal(strct.StopReason); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CreateMessageResult) UnmarshalJSON(b []byte) error {
    contentReceived := false
    modelReceived := false
    roleReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "content":
            if err := json.Unmarshal([]byte(v), &strct.Content); err != nil {
                return err
             }
            contentReceived = true
        case "_meta":
            if err := json.Unmarshal([]byte(v), &strct.Meta); err != nil {
                return err
             }
        case "model":
            if err := json.Unmarshal([]byte(v), &strct.Model); err != nil {
                return err
             }
            modelReceived = true
        case "role":
            if err := json.Unmarshal([]byte(v), &strct.Role); err != nil {
                return err
             }
            roleReceived = true
        case "stopReason":
            if err := json.Unmarshal([]byte(v), &strct.StopReason); err != nil {
                return err
             }
        }
    }
    // check if content (a required property) was received
    if !contentReceived {
        return errors.New("\"content\" is required but was not present")
    }
    // check if model (a required property) was received
    if !modelReceived {
        return errors.New("\"model\" is required but was not present")
    }
    // check if role (a required property) was received
    if !roleReceived {
        return errors.New("\"role\" is required but was not present")
    }
    return nil
}

func (strct *EmbeddedResource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "annotations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"annotations\": ")
	if tmp, err := json.Marshal(strct.Annotations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Resource" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "resource" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"resource\": ")
	if tmp, err := json.Marshal(strct.Resource); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EmbeddedResource) UnmarshalJSON(b []byte) error {
    resourceReceived := false
    typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "annotations":
            if err := json.Unmarshal([]byte(v), &strct.Annotations); err != nil {
                return err
             }
        case "resource":
            if err := json.Unmarshal([]byte(v), &strct.Resource); err != nil {
                return err
             }
            resourceReceived = true
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            typeReceived = true
        }
    }
    // check if resource (a required property) was received
    if !resourceReceived {
        return errors.New("\"resource\" is required but was not present")
    }
    // check if type (a required property) was received
    if !typeReceived {
        return errors.New("\"type\" is required but was not present")
    }
    return nil
}

func (strct *Error) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Code" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "code" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"code\": ")
	if tmp, err := json.Marshal(strct.Code); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "data" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"data\": ")
	if tmp, err := json.Marshal(strct.Data); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Message" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "message" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"message\": ")
	if tmp, err := json.Marshal(strct.Message); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Error) UnmarshalJSON(b []byte) error {
    codeReceived := false
    messageReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "code":
            if err := json.Unmarshal([]byte(v), &strct.Code); err != nil {
                return err
             }
            codeReceived = true
        case "data":
            if err := json.Unmarshal([]byte(v), &strct.Data); err != nil {
                return err
             }
        case "message":
            if err := json.Unmarshal([]byte(v), &strct.Message); err != nil {
                return err
             }
            messageReceived = true
        }
    }
    // check if code (a required property) was received
    if !codeReceived {
        return errors.New("\"code\" is required but was not present")
    }
    // check if message (a required property) was received
    if !messageReceived {
        return errors.New("\"message\" is required but was not present")
    }
    return nil
}

func (strct *ExperimentalItem) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ExperimentalItem) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        default:
            // an additional "interface{}" value
            var additionalValue interface{}
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]interface{}, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    return nil
}

func (strct *GetPromptRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Params" field is required
    if strct.Params == nil {
        return nil, errors.New("params is a required field")
    }
    // Marshal the "params" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *GetPromptRequest) UnmarshalJSON(b []byte) error {
    methodReceived := false
    paramsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
                return err
             }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
                return err
             }
            paramsReceived = true
        }
    }
    // check if method (a required property) was received
    if !methodReceived {
        return errors.New("\"method\" is required but was not present")
    }
    // check if params (a required property) was received
    if !paramsReceived {
        return errors.New("\"params\" is required but was not present")
    }
    return nil
}

func (strct *GetPromptResult) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Messages" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "messages" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"messages\": ")
	if tmp, err := json.Marshal(strct.Messages); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "_meta" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"_meta\": ")
	if tmp, err := json.Marshal(strct.Meta); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *GetPromptResult) UnmarshalJSON(b []byte) error {
    messagesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "messages":
            if err := json.Unmarshal([]byte(v), &strct.Messages); err != nil {
                return err
             }
            messagesReceived = true
        case "_meta":
            if err := json.Unmarshal([]byte(v), &strct.Meta); err != nil {
                return err
             }
        }
    }
    // check if messages (a required property) was received
    if !messagesReceived {
        return errors.New("\"messages\" is required but was not present")
    }
    return nil
}

func (strct *ImageContent) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "annotations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"annotations\": ")
	if tmp, err := json.Marshal(strct.Annotations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Data" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "data" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"data\": ")
	if tmp, err := json.Marshal(strct.Data); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "MimeType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "mimeType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"mimeType\": ")
	if tmp, err := json.Marshal(strct.MimeType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ImageContent) UnmarshalJSON(b []byte) error {
    dataReceived := false
    mimeTypeReceived := false
    typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "annotations":
            if err := json.Unmarshal([]byte(v), &strct.Annotations); err != nil {
                return err
             }
        case "data":
            if err := json.Unmarshal([]byte(v), &strct.Data); err != nil {
                return err
             }
            dataReceived = true
        case "mimeType":
            if err := json.Unmarshal([]byte(v), &strct.MimeType); err != nil {
                return err
             }
            mimeTypeReceived = true
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            typeReceived = true
        }
    }
    // check if data (a required property) was received
    if !dataReceived {
        return errors.New("\"data\" is required but was not present")
    }
    // check if mimeType (a required property) was received
    if !mimeTypeReceived {
        return errors.New("\"mimeType\" is required but was not present")
    }
    // check if type (a required property) was received
    if !typeReceived {
        return errors.New("\"type\" is required but was not present")
    }
    return nil
}

func (strct *Implementation) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Version" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "version" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"version\": ")
	if tmp, err := json.Marshal(strct.Version); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Implementation) UnmarshalJSON(b []byte) error {
    nameReceived := false
    versionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            nameReceived = true
        case "version":
            if err := json.Unmarshal([]byte(v), &strct.Version); err != nil {
                return err
             }
            versionReceived = true
        }
    }
    // check if name (a required property) was received
    if !nameReceived {
        return errors.New("\"name\" is required but was not present")
    }
    // check if version (a required property) was received
    if !versionReceived {
        return errors.New("\"version\" is required but was not present")
    }
    return nil
}

func (strct *InitializeRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Params" field is required
    if strct.Params == nil {
        return nil, errors.New("params is a required field")
    }
    // Marshal the "params" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *InitializeRequest) UnmarshalJSON(b []byte) error {
    methodReceived := false
    paramsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
                return err
             }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
                return err
             }
            paramsReceived = true
        }
    }
    // check if method (a required property) was received
    if !methodReceived {
        return errors.New("\"method\" is required but was not present")
    }
    // check if params (a required property) was received
    if !paramsReceived {
        return errors.New("\"params\" is required but was not present")
    }
    return nil
}

func (strct *InitializeResult) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Capabilities" field is required
    if strct.Capabilities == nil {
        return nil, errors.New("capabilities is a required field")
    }
    // Marshal the "capabilities" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"capabilities\": ")
	if tmp, err := json.Marshal(strct.Capabilities); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "instructions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"instructions\": ")
	if tmp, err := json.Marshal(strct.Instructions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "_meta" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"_meta\": ")
	if tmp, err := json.Marshal(strct.Meta); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ProtocolVersion" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "protocolVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"protocolVersion\": ")
	if tmp, err := json.Marshal(strct.ProtocolVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ServerInfo" field is required
    if strct.ServerInfo == nil {
        return nil, errors.New("serverInfo is a required field")
    }
    // Marshal the "serverInfo" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"serverInfo\": ")
	if tmp, err := json.Marshal(strct.ServerInfo); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *InitializeResult) UnmarshalJSON(b []byte) error {
    capabilitiesReceived := false
    protocolVersionReceived := false
    serverInfoReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "capabilities":
            if err := json.Unmarshal([]byte(v), &strct.Capabilities); err != nil {
                return err
             }
            capabilitiesReceived = true
        case "instructions":
            if err := json.Unmarshal([]byte(v), &strct.Instructions); err != nil {
                return err
             }
        case "_meta":
            if err := json.Unmarshal([]byte(v), &strct.Meta); err != nil {
                return err
             }
        case "protocolVersion":
            if err := json.Unmarshal([]byte(v), &strct.ProtocolVersion); err != nil {
                return err
             }
            protocolVersionReceived = true
        case "serverInfo":
            if err := json.Unmarshal([]byte(v), &strct.ServerInfo); err != nil {
                return err
             }
            serverInfoReceived = true
        }
    }
    // check if capabilities (a required property) was received
    if !capabilitiesReceived {
        return errors.New("\"capabilities\" is required but was not present")
    }
    // check if protocolVersion (a required property) was received
    if !protocolVersionReceived {
        return errors.New("\"protocolVersion\" is required but was not present")
    }
    // check if serverInfo (a required property) was received
    if !serverInfoReceived {
        return errors.New("\"serverInfo\" is required but was not present")
    }
    return nil
}

func (strct *InitializedNotification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "params" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *InitializedNotification) UnmarshalJSON(b []byte) error {
    methodReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
                return err
             }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
                return err
             }
        }
    }
    // check if method (a required property) was received
    if !methodReceived {
        return errors.New("\"method\" is required but was not present")
    }
    return nil
}

func (strct *InputSchema) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "properties" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"properties\": ")
	if tmp, err := json.Marshal(strct.Properties); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "required" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"required\": ")
	if tmp, err := json.Marshal(strct.Required); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *InputSchema) UnmarshalJSON(b []byte) error {
    typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "properties":
            if err := json.Unmarshal([]byte(v), &strct.Properties); err != nil {
                return err
             }
        case "required":
            if err := json.Unmarshal([]byte(v), &strct.Required); err != nil {
                return err
             }
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            typeReceived = true
        }
    }
    // check if type (a required property) was received
    if !typeReceived {
        return errors.New("\"type\" is required but was not present")
    }
    return nil
}

func (strct *JSONRPCError) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Error" field is required
    if strct.Error == nil {
        return nil, errors.New("error is a required field")
    }
    // Marshal the "error" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"error\": ")
	if tmp, err := json.Marshal(strct.Error); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Jsonrpc" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "jsonrpc" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"jsonrpc\": ")
	if tmp, err := json.Marshal(strct.Jsonrpc); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *JSONRPCError) UnmarshalJSON(b []byte) error {
    errorReceived := false
    idReceived := false
    jsonrpcReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "error":
            if err := json.Unmarshal([]byte(v), &strct.Error); err != nil {
                return err
             }
            errorReceived = true
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
            idReceived = true
        case "jsonrpc":
            if err := json.Unmarshal([]byte(v), &strct.Jsonrpc); err != nil {
                return err
             }
            jsonrpcReceived = true
        }
    }
    // check if error (a required property) was received
    if !errorReceived {
        return errors.New("\"error\" is required but was not present")
    }
    // check if id (a required property) was received
    if !idReceived {
        return errors.New("\"id\" is required but was not present")
    }
    // check if jsonrpc (a required property) was received
    if !jsonrpcReceived {
        return errors.New("\"jsonrpc\" is required but was not present")
    }
    return nil
}

func (strct *JSONRPCNotification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Jsonrpc" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "jsonrpc" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"jsonrpc\": ")
	if tmp, err := json.Marshal(strct.Jsonrpc); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "params" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *JSONRPCNotification) UnmarshalJSON(b []byte) error {
    jsonrpcReceived := false
    methodReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "jsonrpc":
            if err := json.Unmarshal([]byte(v), &strct.Jsonrpc); err != nil {
                return err
             }
            jsonrpcReceived = true
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
                return err
             }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
                return err
             }
        }
    }
    // check if jsonrpc (a required property) was received
    if !jsonrpcReceived {
        return errors.New("\"jsonrpc\" is required but was not present")
    }
    // check if method (a required property) was received
    if !methodReceived {
        return errors.New("\"method\" is required but was not present")
    }
    return nil
}

func (strct *JSONRPCRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Jsonrpc" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "jsonrpc" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"jsonrpc\": ")
	if tmp, err := json.Marshal(strct.Jsonrpc); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "params" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *JSONRPCRequest) UnmarshalJSON(b []byte) error {
    idReceived := false
    jsonrpcReceived := false
    methodReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
            idReceived = true
        case "jsonrpc":
            if err := json.Unmarshal([]byte(v), &strct.Jsonrpc); err != nil {
                return err
             }
            jsonrpcReceived = true
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
                return err
             }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
                return err
             }
        }
    }
    // check if id (a required property) was received
    if !idReceived {
        return errors.New("\"id\" is required but was not present")
    }
    // check if jsonrpc (a required property) was received
    if !jsonrpcReceived {
        return errors.New("\"jsonrpc\" is required but was not present")
    }
    // check if method (a required property) was received
    if !methodReceived {
        return errors.New("\"method\" is required but was not present")
    }
    return nil
}

func (strct *JSONRPCResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Jsonrpc" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "jsonrpc" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"jsonrpc\": ")
	if tmp, err := json.Marshal(strct.Jsonrpc); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Result" field is required
    if strct.Result == nil {
        return nil, errors.New("result is a required field")
    }
    // Marshal the "result" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"result\": ")
	if tmp, err := json.Marshal(strct.Result); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *JSONRPCResponse) UnmarshalJSON(b []byte) error {
    idReceived := false
    jsonrpcReceived := false
    resultReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
            idReceived = true
        case "jsonrpc":
            if err := json.Unmarshal([]byte(v), &strct.Jsonrpc); err != nil {
                return err
             }
            jsonrpcReceived = true
        case "result":
            if err := json.Unmarshal([]byte(v), &strct.Result); err != nil {
                return err
             }
            resultReceived = true
        }
    }
    // check if id (a required property) was received
    if !idReceived {
        return errors.New("\"id\" is required but was not present")
    }
    // check if jsonrpc (a required property) was received
    if !jsonrpcReceived {
        return errors.New("\"jsonrpc\" is required but was not present")
    }
    // check if result (a required property) was received
    if !resultReceived {
        return errors.New("\"result\" is required but was not present")
    }
    return nil
}

func (strct *ListPromptsRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "params" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ListPromptsRequest) UnmarshalJSON(b []byte) error {
    methodReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
                return err
             }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
                return err
             }
        }
    }
    // check if method (a required property) was received
    if !methodReceived {
        return errors.New("\"method\" is required but was not present")
    }
    return nil
}

func (strct *ListPromptsResult) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "_meta" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"_meta\": ")
	if tmp, err := json.Marshal(strct.Meta); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "nextCursor" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"nextCursor\": ")
	if tmp, err := json.Marshal(strct.NextCursor); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Prompts" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "prompts" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"prompts\": ")
	if tmp, err := json.Marshal(strct.Prompts); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ListPromptsResult) UnmarshalJSON(b []byte) error {
    promptsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "_meta":
            if err := json.Unmarshal([]byte(v), &strct.Meta); err != nil {
                return err
             }
        case "nextCursor":
            if err := json.Unmarshal([]byte(v), &strct.NextCursor); err != nil {
                return err
             }
        case "prompts":
            if err := json.Unmarshal([]byte(v), &strct.Prompts); err != nil {
                return err
             }
            promptsReceived = true
        }
    }
    // check if prompts (a required property) was received
    if !promptsReceived {
        return errors.New("\"prompts\" is required but was not present")
    }
    return nil
}

func (strct *ListResourceTemplatesRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "params" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ListResourceTemplatesRequest) UnmarshalJSON(b []byte) error {
    methodReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
                return err
             }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
                return err
             }
        }
    }
    // check if method (a required property) was received
    if !methodReceived {
        return errors.New("\"method\" is required but was not present")
    }
    return nil
}

func (strct *ListResourceTemplatesResult) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "_meta" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"_meta\": ")
	if tmp, err := json.Marshal(strct.Meta); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "nextCursor" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"nextCursor\": ")
	if tmp, err := json.Marshal(strct.NextCursor); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ResourceTemplates" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "resourceTemplates" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"resourceTemplates\": ")
	if tmp, err := json.Marshal(strct.ResourceTemplates); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ListResourceTemplatesResult) UnmarshalJSON(b []byte) error {
    resourceTemplatesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "_meta":
            if err := json.Unmarshal([]byte(v), &strct.Meta); err != nil {
                return err
             }
        case "nextCursor":
            if err := json.Unmarshal([]byte(v), &strct.NextCursor); err != nil {
                return err
             }
        case "resourceTemplates":
            if err := json.Unmarshal([]byte(v), &strct.ResourceTemplates); err != nil {
                return err
             }
            resourceTemplatesReceived = true
        }
    }
    // check if resourceTemplates (a required property) was received
    if !resourceTemplatesReceived {
        return errors.New("\"resourceTemplates\" is required but was not present")
    }
    return nil
}

func (strct *ListResourcesRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "params" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ListResourcesRequest) UnmarshalJSON(b []byte) error {
    methodReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
                return err
             }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
                return err
             }
        }
    }
    // check if method (a required property) was received
    if !methodReceived {
        return errors.New("\"method\" is required but was not present")
    }
    return nil
}

func (strct *ListResourcesResult) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "_meta" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"_meta\": ")
	if tmp, err := json.Marshal(strct.Meta); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "nextCursor" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"nextCursor\": ")
	if tmp, err := json.Marshal(strct.NextCursor); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Resources" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "resources" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"resources\": ")
	if tmp, err := json.Marshal(strct.Resources); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ListResourcesResult) UnmarshalJSON(b []byte) error {
    resourcesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "_meta":
            if err := json.Unmarshal([]byte(v), &strct.Meta); err != nil {
                return err
             }
        case "nextCursor":
            if err := json.Unmarshal([]byte(v), &strct.NextCursor); err != nil {
                return err
             }
        case "resources":
            if err := json.Unmarshal([]byte(v), &strct.Resources); err != nil {
                return err
             }
            resourcesReceived = true
        }
    }
    // check if resources (a required property) was received
    if !resourcesReceived {
        return errors.New("\"resources\" is required but was not present")
    }
    return nil
}

func (strct *ListRootsRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "params" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ListRootsRequest) UnmarshalJSON(b []byte) error {
    methodReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
                return err
             }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
                return err
             }
        }
    }
    // check if method (a required property) was received
    if !methodReceived {
        return errors.New("\"method\" is required but was not present")
    }
    return nil
}

func (strct *ListRootsResult) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "_meta" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"_meta\": ")
	if tmp, err := json.Marshal(strct.Meta); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Roots" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "roots" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"roots\": ")
	if tmp, err := json.Marshal(strct.Roots); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ListRootsResult) UnmarshalJSON(b []byte) error {
    rootsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "_meta":
            if err := json.Unmarshal([]byte(v), &strct.Meta); err != nil {
                return err
             }
        case "roots":
            if err := json.Unmarshal([]byte(v), &strct.Roots); err != nil {
                return err
             }
            rootsReceived = true
        }
    }
    // check if roots (a required property) was received
    if !rootsReceived {
        return errors.New("\"roots\" is required but was not present")
    }
    return nil
}

func (strct *ListToolsRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "params" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ListToolsRequest) UnmarshalJSON(b []byte) error {
    methodReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
                return err
             }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
                return err
             }
        }
    }
    // check if method (a required property) was received
    if !methodReceived {
        return errors.New("\"method\" is required but was not present")
    }
    return nil
}

func (strct *ListToolsResult) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "_meta" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"_meta\": ")
	if tmp, err := json.Marshal(strct.Meta); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "nextCursor" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"nextCursor\": ")
	if tmp, err := json.Marshal(strct.NextCursor); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Tools" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tools" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"tools\": ")
	if tmp, err := json.Marshal(strct.Tools); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ListToolsResult) UnmarshalJSON(b []byte) error {
    toolsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "_meta":
            if err := json.Unmarshal([]byte(v), &strct.Meta); err != nil {
                return err
             }
        case "nextCursor":
            if err := json.Unmarshal([]byte(v), &strct.NextCursor); err != nil {
                return err
             }
        case "tools":
            if err := json.Unmarshal([]byte(v), &strct.Tools); err != nil {
                return err
             }
            toolsReceived = true
        }
    }
    // check if tools (a required property) was received
    if !toolsReceived {
        return errors.New("\"tools\" is required but was not present")
    }
    return nil
}

func (strct *Logging) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Logging) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        default:
            // an additional "interface{}" value
            var additionalValue interface{}
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]interface{}, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    return nil
}

func (strct *LoggingMessageNotification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Params" field is required
    if strct.Params == nil {
        return nil, errors.New("params is a required field")
    }
    // Marshal the "params" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LoggingMessageNotification) UnmarshalJSON(b []byte) error {
    methodReceived := false
    paramsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
                return err
             }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
                return err
             }
            paramsReceived = true
        }
    }
    // check if method (a required property) was received
    if !methodReceived {
        return errors.New("\"method\" is required but was not present")
    }
    // check if params (a required property) was received
    if !paramsReceived {
        return errors.New("\"params\" is required but was not present")
    }
    return nil
}

func (strct *Metadata) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Metadata) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        default:
            // an additional "interface{}" value
            var additionalValue interface{}
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]interface{}, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    return nil
}

func (strct *Notification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "params" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Notification) UnmarshalJSON(b []byte) error {
    methodReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
                return err
             }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
                return err
             }
        }
    }
    // check if method (a required property) was received
    if !methodReceived {
        return errors.New("\"method\" is required but was not present")
    }
    return nil
}

func (strct *PaginatedRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "params" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PaginatedRequest) UnmarshalJSON(b []byte) error {
    methodReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
                return err
             }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
                return err
             }
        }
    }
    // check if method (a required property) was received
    if !methodReceived {
        return errors.New("\"method\" is required but was not present")
    }
    return nil
}

func (strct *Params) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "_meta" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"_meta\": ")
	if tmp, err := json.Marshal(strct.Meta); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Params) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "_meta":
            if err := json.Unmarshal([]byte(v), &strct.Meta); err != nil {
                return err
             }
        default:
            // an additional "interface{}" value
            var additionalValue interface{}
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]interface{}, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    return nil
}

func (strct *PingRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "params" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PingRequest) UnmarshalJSON(b []byte) error {
    methodReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
                return err
             }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
                return err
             }
        }
    }
    // check if method (a required property) was received
    if !methodReceived {
        return errors.New("\"method\" is required but was not present")
    }
    return nil
}

func (strct *ProgressNotification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Params" field is required
    if strct.Params == nil {
        return nil, errors.New("params is a required field")
    }
    // Marshal the "params" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ProgressNotification) UnmarshalJSON(b []byte) error {
    methodReceived := false
    paramsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
                return err
             }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
                return err
             }
            paramsReceived = true
        }
    }
    // check if method (a required property) was received
    if !methodReceived {
        return errors.New("\"method\" is required but was not present")
    }
    // check if params (a required property) was received
    if !paramsReceived {
        return errors.New("\"params\" is required but was not present")
    }
    return nil
}

func (strct *Prompt) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "arguments" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"arguments\": ")
	if tmp, err := json.Marshal(strct.Arguments); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Prompt) UnmarshalJSON(b []byte) error {
    nameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "arguments":
            if err := json.Unmarshal([]byte(v), &strct.Arguments); err != nil {
                return err
             }
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            nameReceived = true
        }
    }
    // check if name (a required property) was received
    if !nameReceived {
        return errors.New("\"name\" is required but was not present")
    }
    return nil
}

func (strct *PromptArgument) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "required" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"required\": ")
	if tmp, err := json.Marshal(strct.Required); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PromptArgument) UnmarshalJSON(b []byte) error {
    nameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            nameReceived = true
        case "required":
            if err := json.Unmarshal([]byte(v), &strct.Required); err != nil {
                return err
             }
        }
    }
    // check if name (a required property) was received
    if !nameReceived {
        return errors.New("\"name\" is required but was not present")
    }
    return nil
}

func (strct *PromptListChangedNotification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "params" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PromptListChangedNotification) UnmarshalJSON(b []byte) error {
    methodReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
                return err
             }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
                return err
             }
        }
    }
    // check if method (a required property) was received
    if !methodReceived {
        return errors.New("\"method\" is required but was not present")
    }
    return nil
}

func (strct *PromptMessage) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Content" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "content" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"content\": ")
	if tmp, err := json.Marshal(strct.Content); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Role" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "role" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"role\": ")
	if tmp, err := json.Marshal(strct.Role); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PromptMessage) UnmarshalJSON(b []byte) error {
    contentReceived := false
    roleReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "content":
            if err := json.Unmarshal([]byte(v), &strct.Content); err != nil {
                return err
             }
            contentReceived = true
        case "role":
            if err := json.Unmarshal([]byte(v), &strct.Role); err != nil {
                return err
             }
            roleReceived = true
        }
    }
    // check if content (a required property) was received
    if !contentReceived {
        return errors.New("\"content\" is required but was not present")
    }
    // check if role (a required property) was received
    if !roleReceived {
        return errors.New("\"role\" is required but was not present")
    }
    return nil
}

func (strct *PromptReference) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PromptReference) UnmarshalJSON(b []byte) error {
    nameReceived := false
    typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            nameReceived = true
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            typeReceived = true
        }
    }
    // check if name (a required property) was received
    if !nameReceived {
        return errors.New("\"name\" is required but was not present")
    }
    // check if type (a required property) was received
    if !typeReceived {
        return errors.New("\"type\" is required but was not present")
    }
    return nil
}

func (strct *PropertiesItem) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PropertiesItem) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        default:
            // an additional "interface{}" value
            var additionalValue interface{}
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]interface{}, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    return nil
}

func (strct *ReadResourceRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Params" field is required
    if strct.Params == nil {
        return nil, errors.New("params is a required field")
    }
    // Marshal the "params" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ReadResourceRequest) UnmarshalJSON(b []byte) error {
    methodReceived := false
    paramsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
                return err
             }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
                return err
             }
            paramsReceived = true
        }
    }
    // check if method (a required property) was received
    if !methodReceived {
        return errors.New("\"method\" is required but was not present")
    }
    // check if params (a required property) was received
    if !paramsReceived {
        return errors.New("\"params\" is required but was not present")
    }
    return nil
}

func (strct *ReadResourceResult) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Contents" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "contents" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"contents\": ")
	if tmp, err := json.Marshal(strct.Contents); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "_meta" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"_meta\": ")
	if tmp, err := json.Marshal(strct.Meta); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ReadResourceResult) UnmarshalJSON(b []byte) error {
    contentsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "contents":
            if err := json.Unmarshal([]byte(v), &strct.Contents); err != nil {
                return err
             }
            contentsReceived = true
        case "_meta":
            if err := json.Unmarshal([]byte(v), &strct.Meta); err != nil {
                return err
             }
        }
    }
    // check if contents (a required property) was received
    if !contentsReceived {
        return errors.New("\"contents\" is required but was not present")
    }
    return nil
}

func (strct *Request) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "params" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Request) UnmarshalJSON(b []byte) error {
    methodReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
                return err
             }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
                return err
             }
        }
    }
    // check if method (a required property) was received
    if !methodReceived {
        return errors.New("\"method\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "annotations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"annotations\": ")
	if tmp, err := json.Marshal(strct.Annotations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "mimeType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"mimeType\": ")
	if tmp, err := json.Marshal(strct.MimeType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Uri" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "uri" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"uri\": ")
	if tmp, err := json.Marshal(strct.Uri); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    nameReceived := false
    uriReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "annotations":
            if err := json.Unmarshal([]byte(v), &strct.Annotations); err != nil {
                return err
             }
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "mimeType":
            if err := json.Unmarshal([]byte(v), &strct.MimeType); err != nil {
                return err
             }
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            nameReceived = true
        case "uri":
            if err := json.Unmarshal([]byte(v), &strct.Uri); err != nil {
                return err
             }
            uriReceived = true
        }
    }
    // check if name (a required property) was received
    if !nameReceived {
        return errors.New("\"name\" is required but was not present")
    }
    // check if uri (a required property) was received
    if !uriReceived {
        return errors.New("\"uri\" is required but was not present")
    }
    return nil
}

func (strct *ResourceContents) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "mimeType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"mimeType\": ")
	if tmp, err := json.Marshal(strct.MimeType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Uri" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "uri" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"uri\": ")
	if tmp, err := json.Marshal(strct.Uri); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ResourceContents) UnmarshalJSON(b []byte) error {
    uriReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "mimeType":
            if err := json.Unmarshal([]byte(v), &strct.MimeType); err != nil {
                return err
             }
        case "uri":
            if err := json.Unmarshal([]byte(v), &strct.Uri); err != nil {
                return err
             }
            uriReceived = true
        }
    }
    // check if uri (a required property) was received
    if !uriReceived {
        return errors.New("\"uri\" is required but was not present")
    }
    return nil
}

func (strct *ResourceListChangedNotification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "params" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ResourceListChangedNotification) UnmarshalJSON(b []byte) error {
    methodReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
                return err
             }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
                return err
             }
        }
    }
    // check if method (a required property) was received
    if !methodReceived {
        return errors.New("\"method\" is required but was not present")
    }
    return nil
}

func (strct *ResourceReference) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Uri" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "uri" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"uri\": ")
	if tmp, err := json.Marshal(strct.Uri); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ResourceReference) UnmarshalJSON(b []byte) error {
    typeReceived := false
    uriReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            typeReceived = true
        case "uri":
            if err := json.Unmarshal([]byte(v), &strct.Uri); err != nil {
                return err
             }
            uriReceived = true
        }
    }
    // check if type (a required property) was received
    if !typeReceived {
        return errors.New("\"type\" is required but was not present")
    }
    // check if uri (a required property) was received
    if !uriReceived {
        return errors.New("\"uri\" is required but was not present")
    }
    return nil
}

func (strct *ResourceTemplate) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "annotations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"annotations\": ")
	if tmp, err := json.Marshal(strct.Annotations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "mimeType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"mimeType\": ")
	if tmp, err := json.Marshal(strct.MimeType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "UriTemplate" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "uriTemplate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"uriTemplate\": ")
	if tmp, err := json.Marshal(strct.UriTemplate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ResourceTemplate) UnmarshalJSON(b []byte) error {
    nameReceived := false
    uriTemplateReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "annotations":
            if err := json.Unmarshal([]byte(v), &strct.Annotations); err != nil {
                return err
             }
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "mimeType":
            if err := json.Unmarshal([]byte(v), &strct.MimeType); err != nil {
                return err
             }
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            nameReceived = true
        case "uriTemplate":
            if err := json.Unmarshal([]byte(v), &strct.UriTemplate); err != nil {
                return err
             }
            uriTemplateReceived = true
        }
    }
    // check if name (a required property) was received
    if !nameReceived {
        return errors.New("\"name\" is required but was not present")
    }
    // check if uriTemplate (a required property) was received
    if !uriTemplateReceived {
        return errors.New("\"uriTemplate\" is required but was not present")
    }
    return nil
}

func (strct *ResourceUpdatedNotification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Params" field is required
    if strct.Params == nil {
        return nil, errors.New("params is a required field")
    }
    // Marshal the "params" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ResourceUpdatedNotification) UnmarshalJSON(b []byte) error {
    methodReceived := false
    paramsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
                return err
             }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
                return err
             }
            paramsReceived = true
        }
    }
    // check if method (a required property) was received
    if !methodReceived {
        return errors.New("\"method\" is required but was not present")
    }
    // check if params (a required property) was received
    if !paramsReceived {
        return errors.New("\"params\" is required but was not present")
    }
    return nil
}

func (strct *Result) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "_meta" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"_meta\": ")
	if tmp, err := json.Marshal(strct.Meta); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Result) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "_meta":
            if err := json.Unmarshal([]byte(v), &strct.Meta); err != nil {
                return err
             }
        default:
            // an additional "interface{}" value
            var additionalValue interface{}
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]interface{}, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    return nil
}

func (strct *Root) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Uri" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "uri" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"uri\": ")
	if tmp, err := json.Marshal(strct.Uri); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Root) UnmarshalJSON(b []byte) error {
    uriReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "uri":
            if err := json.Unmarshal([]byte(v), &strct.Uri); err != nil {
                return err
             }
            uriReceived = true
        }
    }
    // check if uri (a required property) was received
    if !uriReceived {
        return errors.New("\"uri\" is required but was not present")
    }
    return nil
}

func (strct *RootsListChangedNotification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "params" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RootsListChangedNotification) UnmarshalJSON(b []byte) error {
    methodReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
                return err
             }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
                return err
             }
        }
    }
    // check if method (a required property) was received
    if !methodReceived {
        return errors.New("\"method\" is required but was not present")
    }
    return nil
}

func (strct *Sampling) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Sampling) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        default:
            // an additional "interface{}" value
            var additionalValue interface{}
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]interface{}, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    return nil
}

func (strct *SamplingMessage) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Content" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "content" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"content\": ")
	if tmp, err := json.Marshal(strct.Content); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Role" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "role" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"role\": ")
	if tmp, err := json.Marshal(strct.Role); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SamplingMessage) UnmarshalJSON(b []byte) error {
    contentReceived := false
    roleReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "content":
            if err := json.Unmarshal([]byte(v), &strct.Content); err != nil {
                return err
             }
            contentReceived = true
        case "role":
            if err := json.Unmarshal([]byte(v), &strct.Role); err != nil {
                return err
             }
            roleReceived = true
        }
    }
    // check if content (a required property) was received
    if !contentReceived {
        return errors.New("\"content\" is required but was not present")
    }
    // check if role (a required property) was received
    if !roleReceived {
        return errors.New("\"role\" is required but was not present")
    }
    return nil
}

func (strct *SetLevelRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Params" field is required
    if strct.Params == nil {
        return nil, errors.New("params is a required field")
    }
    // Marshal the "params" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SetLevelRequest) UnmarshalJSON(b []byte) error {
    methodReceived := false
    paramsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
                return err
             }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
                return err
             }
            paramsReceived = true
        }
    }
    // check if method (a required property) was received
    if !methodReceived {
        return errors.New("\"method\" is required but was not present")
    }
    // check if params (a required property) was received
    if !paramsReceived {
        return errors.New("\"params\" is required but was not present")
    }
    return nil
}

func (strct *SubscribeRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Params" field is required
    if strct.Params == nil {
        return nil, errors.New("params is a required field")
    }
    // Marshal the "params" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SubscribeRequest) UnmarshalJSON(b []byte) error {
    methodReceived := false
    paramsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
                return err
             }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
                return err
             }
            paramsReceived = true
        }
    }
    // check if method (a required property) was received
    if !methodReceived {
        return errors.New("\"method\" is required but was not present")
    }
    // check if params (a required property) was received
    if !paramsReceived {
        return errors.New("\"params\" is required but was not present")
    }
    return nil
}

func (strct *TextContent) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "annotations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"annotations\": ")
	if tmp, err := json.Marshal(strct.Annotations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Text" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "text" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"text\": ")
	if tmp, err := json.Marshal(strct.Text); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TextContent) UnmarshalJSON(b []byte) error {
    textReceived := false
    typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "annotations":
            if err := json.Unmarshal([]byte(v), &strct.Annotations); err != nil {
                return err
             }
        case "text":
            if err := json.Unmarshal([]byte(v), &strct.Text); err != nil {
                return err
             }
            textReceived = true
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            typeReceived = true
        }
    }
    // check if text (a required property) was received
    if !textReceived {
        return errors.New("\"text\" is required but was not present")
    }
    // check if type (a required property) was received
    if !typeReceived {
        return errors.New("\"type\" is required but was not present")
    }
    return nil
}

func (strct *TextResourceContents) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "mimeType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"mimeType\": ")
	if tmp, err := json.Marshal(strct.MimeType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Text" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "text" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"text\": ")
	if tmp, err := json.Marshal(strct.Text); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Uri" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "uri" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"uri\": ")
	if tmp, err := json.Marshal(strct.Uri); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TextResourceContents) UnmarshalJSON(b []byte) error {
    textReceived := false
    uriReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "mimeType":
            if err := json.Unmarshal([]byte(v), &strct.MimeType); err != nil {
                return err
             }
        case "text":
            if err := json.Unmarshal([]byte(v), &strct.Text); err != nil {
                return err
             }
            textReceived = true
        case "uri":
            if err := json.Unmarshal([]byte(v), &strct.Uri); err != nil {
                return err
             }
            uriReceived = true
        }
    }
    // check if text (a required property) was received
    if !textReceived {
        return errors.New("\"text\" is required but was not present")
    }
    // check if uri (a required property) was received
    if !uriReceived {
        return errors.New("\"uri\" is required but was not present")
    }
    return nil
}

func (strct *Tool) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "InputSchema" field is required
    if strct.InputSchema == nil {
        return nil, errors.New("inputSchema is a required field")
    }
    // Marshal the "inputSchema" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"inputSchema\": ")
	if tmp, err := json.Marshal(strct.InputSchema); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tool) UnmarshalJSON(b []byte) error {
    inputSchemaReceived := false
    nameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "inputSchema":
            if err := json.Unmarshal([]byte(v), &strct.InputSchema); err != nil {
                return err
             }
            inputSchemaReceived = true
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            nameReceived = true
        }
    }
    // check if inputSchema (a required property) was received
    if !inputSchemaReceived {
        return errors.New("\"inputSchema\" is required but was not present")
    }
    // check if name (a required property) was received
    if !nameReceived {
        return errors.New("\"name\" is required but was not present")
    }
    return nil
}

func (strct *ToolListChangedNotification) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "params" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ToolListChangedNotification) UnmarshalJSON(b []byte) error {
    methodReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
                return err
             }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
                return err
             }
        }
    }
    // check if method (a required property) was received
    if !methodReceived {
        return errors.New("\"method\" is required but was not present")
    }
    return nil
}

func (strct *UnsubscribeRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Params" field is required
    if strct.Params == nil {
        return nil, errors.New("params is a required field")
    }
    // Marshal the "params" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *UnsubscribeRequest) UnmarshalJSON(b []byte) error {
    methodReceived := false
    paramsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
                return err
             }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
                return err
             }
            paramsReceived = true
        }
    }
    // check if method (a required property) was received
    if !methodReceived {
        return errors.New("\"method\" is required but was not present")
    }
    // check if params (a required property) was received
    if !paramsReceived {
        return errors.New("\"params\" is required but was not present")
    }
    return nil
}
